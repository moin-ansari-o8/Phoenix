---getTime and getRepeat---
    ok so now, i want to make a getTime function and a getRepeat function. both will take a string argument.
    string can be: "set alarm for 10:00","set alarm for 11:00 a.m./am/pm/p.m."
    getTime(query):
        check for "set alarm for" key word:
            if HH:MM after keyword :
                hour=HH
                min=MM
            else
                didn't get get the time properly
                input("HH:MM")
                hour=HH
                min=MM
            if hour>12
                ex: hour=14 then hour=2 and period = p.m. and if

            if after hh:mm format in query if written "a.m/am/p.m/..etc":
                period = "a.m./p.m"#accordingly
        return hour,min,period

    getRepeat(query):
        if query has word like: |daily|once|next|monday|tuesday|wednesday|thursday|friday|saturday|sunday
            return that word
        return once
            ###############done####################

---make handleAlarmPrompt---
    make method named:: handleAlarmPrompt(query) 
    method's row working flow in python::
    handleAlarmPrompt(query):
        hour,minute,period = getTime(query) # it is already made so don't make it's code
        repeat = getRepeat(query) # it is already made so don't make it's code
        while true:
            print("enter label(print no if you don't want to):") #don't change
            lbl = self.take_command().lower().strip() #don't change this line to
            if lbl:
                if "no" in lbl :
                    lbl = "alarm"
                    break
                else:
                    break
            
        generate unique id: "A_random"
        speak:"alarm set for {hr}:{min} for {repeat}"

        make json file named alarm.json in that file it should store data in this manner:
        "
        {
        "alarms": [
            {
                "id": "A_id",
                "ringAlarm": [
                    hour,
                    min,
                    period
                ],
                "label": "lbl",
                "repeat": "reapeat",
                "delete?": false # by default always false
            },
            {
                "id": "A_179",
                "ringAlarm": [
                    12,
                    30,
                    "a.m."
                ],
                "label": "alarm",
                "repeat": "once",
                "delete": false
            }

        ]
        }
        "

---updated getRepeat to return set---
    make method named:: getRepeat(query)
    what this method should return : return {repeat:[days]} # returns dictionary
    notes: days will store list like this:["MO","TU","WE","TH","FR","ST","SU","TODAY"] where MO is monday...SU is sunday and TODAY
    getRepeat(query):
        if query has string like this : set alarm for 12:00 for {daily || today || tomorrw || every {monday||tuesday||...||sunday} || } or similar    
            if query contains  "daily" then: 
                repeat="daily"
                days=["TODAY"]
            elif query contains  "today" then: 
                repeat="once"
                days=["TODAY"]
            elif query contains  "tomorrow" then: 
                repeat="once"
                days=[{today's day+1}] # ex if today is monday then days=["TU"]
            if query contains  "every" then: 
                day=find day after "every" word in query
                days=[day] # ex if there is every monday then day="monday" and therefore days=["monday"]
                repeat="weekly"
        else
            ask:you want for any perticular day,weekly or something? 
            if yes then:
                repeat = takeinput for repeat(weekly/daily/monthly/?)
                if daily: then return {"daily":["TODAY"]}
                else:
                    takeinput : enter days seperate multiple days using space ex: monday tuesday friday
                    days = days list
            else:
                return {"once":["TODAY"]}
        return {repeat:days}

---updated handleAlarmPrompt for repeat as set---
    update method named:: handleAlarmPrompt(query) 
    subject:: update the json structure 
    goal of json structure::
    "
    {
        "alarms": [
            {
                "id": "A_179",
                "ringAlarm": [
                    12,
                    30,
                    "a.m."
                ],
                "label": "alarm",
                "day":["days"],#["MO","TU","WE","TH","FR","ST","SU","TODAY"]
                "repeat": "once",#"weekly","monthly","daily"
                "ringed": {1:true} # {number of how many times the alarm is ringed : remove the alarm}
            }
        ]
    }
    notes:: before the getRepeat was just returning one value but now it returns the set like this : {"once":["TODAY"]} || {"weekly":["MO","TU"]}
    "
    existing code:
    "
    def handleAlarmPrompt(self, query):
            # Get time details from query using getTime method
            hour, minute, period = self.getTime(query)  # Assuming getTime is already implemented
            if period=="not found":
                print("string Not for alarm")
                return
            elif period=="loop out":
                return
            # Get repeat details from query using getRepeat method
            repeat = self.getRepeat(query)  # Assuming getRepeat is already implemented
            # here repeat has this king of value{"once":["MO","TU"]}
            # Loop to get the label
        # Loop to get the label
            # Loop to get the label
            while True:
                print(f"Speak the label name or 'no' to just come out of the loop for: {hour}:{minute}:")  # Don't change
                lbl = self.take_command()  # Don't change this line
                if lbl:  # Check if input is valid
                    lbl = lbl.lower().strip()  # Convert to lowercase and strip whitespace
                    if "no" in lbl:  # If input contains "no", set label to "alarm"
                        lbl = "alarm"
                    break  # Exit loop as lbl is processed


            
            # Generate a unique ID
            unique_id = f"A_{uuid.uuid4().hex[:6]}"
            print(f"Please confirm the details:\nTime: {hour}:{minute} {period}\nRepeat: {repeat}\nLabel: {lbl}")
            confirmation = input("Type 'Y' to confirm, anything else to cancel: ").strip().lower()
            if confirmation != "y":
                print("Operation cancelled.")
                return  # Exit the method
            # Confirm alarm set
            print(f"Alarm set for {hour}:{minute} {period} for {repeat}")
            
            # Prepare alarm data
            alarm_data = {
                "id": unique_id,
                "ringAlarm": [hour, minute, period],
                "label": lbl,
                "repeat": repeat,
                "delete?": False
            }
            
            # Load existing alarms from file or create a new structure
            try:
                with open(self.alarm_file, "r") as file:
                    alarms = json.load(file)
            except FileNotFoundError:
                alarms = {"alarms": []}
            
            # Add the new alarm
            alarms["alarms"].append(alarm_data)
            
            # Save updated alarms back to the file
            with open(self.alarm_file, "w") as file:
                json.dump(alarms, file, indent=4)

    "
    update this part: from using repeat set.

    
            alarm_data = {
                "id": unique_id,
                "ringAlarm": [hour, minute, period],
                "label": lbl,
                "days": list value of the repeat set,
                "repeat": key of repeat,
                "delete?": False
            }

---deletealarm---

    make a method that removes the alarm from the json file structure like this file=self.alarm_file;
    remove alarm where delete = true, get label of deleted id and print "alarm deleted for label :{label}"
    "
    {
    "alarms": [
        {
        "id": "a170",
        "setAlarm": [23, 53],
        "ringAlarm": [23, 53],
        "label": "go to sleep",
        "repeat": "once",
        "delete": true
        },
        {
        "id": "A_304825",
        "ringAlarm": [8, 0, "p.m."],
        "label": "alarm",
        "repeat": "once",
        "delete": true
        },
        {
        "id": "A_318bc1",
        "ringAlarm": [12, 0, "p.m."],
        "label": "casual",
        "repeat": "once",
        "delete": false
        },
        {
        "id": "A_0a5ed9",
        "ringAlarm": [8, 45, "a.m."],
        "label": "makeup",
        "repeat": "once",
        "delete": false
        },
        {
        "id": "A_189aa5",
        "ringAlarm": [1, 59, "p.m."],
        "label": "just checking",
        "day": ["TODAY"],
        "repeat": "once",
        "ringed": 0,
        "delete": false
        },
        {
        "id": "A_720097",
        "ringAlarm": [2, 30, "p.m."],
        "label": "just checking twice",
        "day": ["TODAY"],
        "repeat": "daily",
        "ringed": 0,
        "delete": false
        },
        {
        "id": "A_b56037",
        "ringAlarm": [2, 30, "p.m."],
        "label": "just checking thrice",
        "day": ["FR", "TU", "WE"],
        "repeat": "weekly",
        "ringed": 0,
        "delete": false
        }
    ]
    }
    "

---chkAlarm---
    this is json file included in class as self.alarm_file::
    {
    "alarms": [
        {
        "id": "a170",
        "setAlarm": [23, 53],
        "ringAlarm": [23, 53],
        "label": "go to sleep",
        "repeat": "once",
        "delete": true
        },
        {
        "id": "A_304825",
        "ringAlarm": [8, 0, "p.m."],
        "label": "alarm",
        "repeat": "once",
        "delete": true
        },
        {
        "id": "A_720097",
        "ringAlarm": [2, 30, "p.m."],
        "label": "just checking twice",
        "day": ["TODAY"],
        "repeat": "daily",
        "ringed": 0,
        "delete": false
        },
        {
        "id": "A_b56037",
        "ringAlarm": [2, 30, "p.m."],
        "label": "just checking thrice",
        "day": ["FR", "TU", "WE"],
        "repeat": "weekly",
        "ringed": 0,
        "delete": false
        }
    ]
    }

    make method name :: chkAlarm(self)
    notes :: 
        self.removeDeletedAlarm() is already made, don't make it's code
        init method of class has :: days_mapping = {
            "monday": "MO", "tuesday": "TU", "wednesday": "WE",
            "thursday": "TH", "friday": "FR", "saturday": "ST", "sunday": "SU"
        }
        make threads for each alarm assigned

    method logic::
        self.removeDeletedAlarm() 
        today = get today's day
        #handle today from days_mapping
        for each alarm in alarms:
            if today in day list of the alarm json file
                curtime = get current time
                if the ringAlarm time from the json file's alarm is > curtime:
                    run the alarm ring thread # make a method that rings alarm when the time comes.

---refactor chkAlarm logic---
    existing code:
    "
        def chkAlarm(self):
        """
        Checks and schedules alarms for today if their ring time is in the future.
        """
        self.removeDeletedAlarms()

        # Load alarms from the file
        try:
            with open(self.alarm_file, "r") as file:
                data = json.load(file)
                alarms = data.get("alarms", [])
        except (FileNotFoundError, json.JSONDecodeError):
            print("Error loading alarms. Please check the file.")
            return

        # Get today's day in abbreviated form (e.g., "MO" for Monday)
        today = datetime.datetime.now().strftime("%A").lower()
        today_abbr = self.days_mapping.get(today)
        print(today_abbr)
        if not today_abbr:
            print("Could not determine today's day.")
            return

        # Iterate through alarms
        for alarm in alarms:
            alarm_days = alarm.get("day", [])
            ring_time = alarm.get("ringAlarm", [])
            print("entered in for loop")
            print(alarm_days)
            print(ring_time)
            # Check if the alarm is set for today and has a valid ring time
            if today_abbr in alarm_days and len(ring_time) >= 2:
                now = datetime.datetime.now()
                alarm_hour, alarm_minute = ring_time[:2]
                print("is conatain")
                print(alarm_hour," ",alarm_minute)
                current_time = now.hour * 60 + now.minute
                alarm_time_in_minutes = alarm_hour * 60 + alarm_minute
                print(alarm_time_in_minutes)
                if alarm_time_in_minutes > current_time:
                    # Schedule the alarm in a separate thread
                    print(f"Scheduling alarm for label: {alarm.get('label')}")
                    threading.Thread(target=self.ringAlarm, args=(alarm,)).start()
    "

    logic::
        remove deleted alarms function
        get today and map it
        for alarm in alarms:
            check if today's day is in the alarm's day list:
                get the hour,minute,period from the ringAlarm attribute of alarm and compare it with the current time # this is how it is written in alarm :: "ringAlarm": [3, 21, "p.m."] 
                if the ringAlarm is not passed means the ringAlarm's time is still about to come in future before today's day is over:
                    run the startAlarm function in thread 
                    in the startalarm it'll start the alarm and when time comes the alarm shall ring.

---error in runAndwait---
    error in thread using speak function:
    "
    File "e:\STDY\GIT_PROJECTS\Phoenix\HelperPhoenix.py", line 59, in speak
    self.engine.runAndWait()
    File "C:\Users\monst\AppData\Roaming\Python\Python311\site-packages\pyttsx3\engine.py", line 177, in runAndWait
    raise RuntimeError('run loop already started')
    RuntimeError: run loop already started
    "

    speak function class:
    "
    class SpeechEngine: # Text-to-Speech Engine
    def __init__(self):
        self.engine = pyttsx3.init('sapi5')
        voices = self.engine.getProperty('voices')
        self.engine.setProperty('voice', voices[1].id)
        self.engine.setProperty('rate', 174)
    
    def speak(self, audio):
        # Replace "sir" with a random respectful term
        replacements = ["boss", "my lord"]
        for punctuation in ["", "?", "!", ".", " "]:
            if f"sir{punctuation}" in audio:
                replacement = random.choice(replacements)
                audio = audio.replace(f"sir{punctuation}", f"{replacement}{punctuation}") 
                break
        self.engine.say(audio)
        print(f"$ : {audio}")
        self.engine.runAndWait()
    "
    methods that are connected with the thread:
    "
        def startAlarm(self, alarm):
        """Starts the alarm thread and rings it when the time comes."""
        ring_time = alarm.get("ringAlarm", [])
        label = alarm.get("label", "")

        if len(ring_time) >= 3:
            hour, minute, period = ring_time
            now = datetime.datetime.now()

            # Convert 12-hour format to 24-hour format
            if period.lower() == "p.m." and hour != 12:
                hour += 12
            elif period.lower() == "a.m." and hour == 12:
                hour = 0

            # Calculate the difference between current time and alarm time
            alarm_time = now.replace(hour=hour, minute=minute, second=0, microsecond=0)
            time_difference = (alarm_time - now).total_seconds()

            if time_difference > 0:
                print(f"Alarm '{label}' scheduled to ring in {time_difference // 60:.0f} minutes.")
                threading.Timer(time_difference, self.ringAlarm, args=(alarm,)).start()

    def ringAlarm(self, alarm):
        """Rings the alarm."""
        try:
            with open(self.alarm_file, "r") as file:
                data = json.load(file)

            for item in data["alarms"]:
                if item["id"] == alarm["id"]:
                    item["ringed"] = item.get("ringed", 0) + 1
                    break

            # Write the updated JSON back to the file
            with open(self.alarm_file, "w") as file:
                json.dump(data, file, indent=4)

        except Exception as e:
            print(f"Error updating alarm: {e}")

        label = alarm.get("label", "No Label")
        self.speak(f"\n*** Alarm '{label}' is ringing! ***")

    def chkAlarm(self):
        """Checks and schedules alarms for today if their ring time is in the future."""
        self.removeDeletedAlarms()

        # Load alarms from the file
        try:
            with open(self.alarm_file, "r") as file:
                data = json.load(file)
                alarms = data.get("alarms", [])
        except (FileNotFoundError, json.JSONDecodeError):
            print("Error loading alarms. Please check the file.")
            return

        # Get today's day in abbreviated form (e.g., "MO" for Monday)
        today = datetime.datetime.now().strftime("%A").lower()
        today_abbr = self.days_mapping.get(today)
        if not today_abbr:
            print("Could not determine today's day.")
            return

        # Iterate through alarms
        for alarm in alarms:
            alarm_days = alarm.get("day", [])
            ring_time = alarm.get("ringAlarm", [])

            # Check if the alarm is set for today and has a valid ring time
            if today_abbr in alarm_days and len(ring_time) >= 3:
                hour, minute, period = ring_time
                now = datetime.datetime.now()

                # Convert 12-hour format to 24-hour format
                if period.lower() == "p.m." and hour != 12:
                    hour += 12
                elif period.lower() == "a.m." and hour == 12:
                    hour = 0

                current_time = now.hour * 60 + now.minute
                alarm_time_in_minutes = hour * 60 + minute

                if alarm_time_in_minutes > current_time:
                    print(f"Scheduling alarm for label: {alarm.get('label')}")
                    self.startAlarm(alarm)

    "

--setReminder---
    make a method according to the request, 
    u can improve the logic if you think it would be better, 
    also tell me the changes u made. 
    request:
    "
    json file structure::
    {
        "reminders": [
            {
            "id": "R_720097", # unique_id starting with R_
            "date": "13-01-25", # "DD-MM-YY"
            "day": "MO",
            "time": "12:00", # time in 24hr format HH:MM
            "message": "Reminder for filling up form",
            "reminded": false
            }
        ]
    }
    notes::
    init method of class has :: days_mapping = {
            "monday": "MO", "tuesday": "TU", "wednesday": "WE",
            "thursday": "TH", "friday": "FR", "saturday": "ST", "sunday": "SU"
        }
    
    logic::
        make a setReminder that takes query as argument:
        message="";date="",day="",time=""
        queries can be : "set reminder for tomorrow","set reminder for next {monday/tuesday.../sunday}"
       if query has tomorrow then get today's date aand date=date+1
        if query has something else like: "set reminder for ..xyz" then: message=..xyz
        if not message:
            while true:
                take message as input
                if taken then get out of loop
        day = getday()

        make json file : as told before

        reminder set for {message}, i will remind you on {12th January}
    "

------------
    existing code::
    # Parse query for date or day
        query = query.lower()
        today = datetime.datetime.now()

        if "tomorrow" in query:
            next_day = today + datetime.timedelta(days=1)
            reminder_date = next_day.strftime("%d-%m-%y")
            reminder_day = self.days_mapping[next_day.strftime("%A").lower()]
        elif "next" in query:
            for day in self.days_mapping.keys():
                if day in query:
                    reminder_date = self.get_next_day(day)
                    reminder_day = self.days_mapping[day]
                    message = query.split("for", 1)[1].strip()
        else:
            # If the query doesn't contain "tomorrow" or "next {day}"
            parts = query.split("for", 1)
            if len(parts) > 1:
                message = parts[1].strip()
            else:
                message = query.strip()

    new logic row code::
        queries = query.split("for")  
        #ex if query = "set reminder for tomorrow for meeting" then queries[0]=set reminder for queries[1] = tomorrow and queries[2] = meeting
        if "tomorrow" in queries[1]:
             reminder_date = next_day.strftime("%d-%m-%y")
            reminder_day = self.days_mapping[next_day.strftime("%A").lower()]
        elif "next" in queries[1]:
            for day in self.days_mapping.keys():
                if day in query:
                    reminder_date = self.get_next_day(day)
                    reminder_day = self.days_mapping[day]
        if queries[2] : #if there is any queries[2] then
            message = queries[2]

---------------------
    make a filter reminder method for the json file structure:this is reminders.json file::
    "
   {
        "reminders": [
            {
                "id": "R_839787",
                "date": "14-01-25",
                "day": "TU",
                "time": "09:00",
                "message": "just casual thing",
                "reminded": false
            },
            {
                "id": "R_278989",
                "date": "20-01-25",
                "day": "MO",
                "time": "09:00",
                "message": "another",
                "reminded": false
            },
            {
                "id": "R_357261",
                "date": "14-01-25",
                "day": "TU",
                "time": "09:00",
                "message": "filling up",
                "reminded": false
            },
            {
                "id": "R_931371",
                "date": "14-01-25",
                "day": "TU",
                "time": "09:00",
                "message": "uttrayan",
                "reminded": false
            },
            {
                "id": "R_166793",
                "date": "15-01-25",
                "day": "WE",
                "time": "08:00",
                "message": "next wednesday for chilling",
                "reminded": false
            },
            {
                "id": "R_699842",
                "date": "15-01-25",
                "day": "WE",
                "time": "08:00",
                "message": "next wednesday for chilling",
                "reminded": false
            },
            {
                "id": "R_697134",
                "date": "15-01-25",
                "day": "WE",
                "time": "09:00",
                "message": "chilling",
                "reminded": false
            }
        ]
    }
    "
    step1:if reminded is true then delete that reminder remove that reminder from the json file
    from all reminders if more than one reminder has same date and time and message then filter it and keep only one of them
    if the date and time is same and message is different then save it in json like this:"message":["msg1","msg2"]
-----------------------------
    add one more functionality to the filterreminder method: if the reminder date is of past date then current date then remove that reminder
    add this functionality to this code, don't change the existing code logic.existing code:"try:
            # Step 1: Load the JSON file
            with open(self.reminder_file, "r") as file:
                data = json.load(file)

            reminders = data.get("reminders", [])

            # Step 2: Remove reminders where "reminded" is true
            filtered_reminders = [r for r in reminders if not r.get("reminded", False)]

            # Step 3: Filter duplicates and handle the message aggregation
            unique_reminders = defaultdict(
                lambda: {
                    "id": None,
                    "date": None,
                    "day": None,
                    "time": None,
                    "message": [],
                    "reminded": False,
                }
            )

            for reminder in filtered_reminders:
                key = (reminder["date"], reminder["time"])  # Group by date and time
                if not unique_reminders[key]["id"]:
                    unique_reminders[key]["id"] = reminder["id"]
                    unique_reminders[key]["date"] = reminder["date"]
                    unique_reminders[key]["day"] = reminder["day"]
                    unique_reminders[key]["time"] = reminder["time"]
                    unique_reminders[key]["reminded"] = reminder["reminded"]

                if isinstance(reminder["message"], list):
                    unique_reminders[key]["message"].extend(reminder["message"])
                else:
                    unique_reminders[key]["message"].append(reminder["message"])

            # Convert defaultdict to a list of reminders with combined messages
            final_reminders = []
            for key, value in unique_reminders.items():
                value["message"] = list(
                    set(value["message"])
                )  # Remove duplicate messages within the list
                final_reminders.append(value)

            # Step 4: Update the JSON file with filtered reminders
            data["reminders"] = final_reminders

            with open(self.reminder_file, "w") as file:
                json.dump(data, file, indent=4)

            print("Reminders have been successfully filtered and updated.")

        except Exception as e:
            print(f"An error occurred: {e}")

    "
---------------
    now make the ringReminder method, 
        if the current date for reminder in reminders:
            if there is still time to ring the reminder:#chk after comparing with current time
                 if yes then run the reminder ringer in the seperate thread  # when ringed the reminder make "reminded":true
            else:
                print("you have missed reminder : reminder["message"]")
    
    json file:
    "
    {
  "reminders": [
    {
      "id": "R_839787",
      "date": "14-01-25",
      "day": "TU",
      "time": "09:00",
      "message": ["just casual thing", "filling up", "uttrayan"],
      "reminded": false
    },
    {
      "id": "R_278989",
      "date": "20-01-25",
      "day": "MO",
      "time": "09:00",
      "message": ["another"],
      "reminded": false
    },
    {
      "id": "R_697134",
      "date": "15-01-25",
      "day": "WE",
      "time": "09:00",
      "message": ["chilling"],
      "reminded": false
    },
    {
      "id": "R_655510",
      "date": "18-01-25",
      "day": "ST",
      "time": "09:00",
      "message": ["chilling majja", "chilling"],
      "reminded": false
    }
  ]
    }

        "
-----------------
    json file:
    "
    {
        "schedule": [
            {
            "time": "05:00",
            "message": "Wake up, eat banana, and perform Fajr prayer."
            },
            {
            "time": "05:30",
            "message": "Time for running."
            },
            {
            "time": "06:30",
            "message": "Time for workout."
            },
            {
            "time": "07:30",
            "message": "Time for a bath."
            }
        ]
    }

    "
    make a class method to add a new schedule routine to the json file.
     method name addSchedule , takes query as argument,  query can be :"add schedule at 12:00","add schedule at 13:00 for lunch"