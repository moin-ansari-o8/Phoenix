1.request for logic and improved logics :

make a method according to the request, 
u can improve the logic if you think it would be better, 
also tell me the changes u made. 
request:""

---------------------------------------------------------------------------------------------------------------
    existing code of viewschedule::
        def viewSchedule(self):
            """
            Displays the schedule from schedule.json in a readable format.
            """
            try:
                # Load data from the JSON file
                with open(self.schedule_file, "r") as file:
                    data = json.load(file)

                # Check if the file has a "schedule" key
                if "schedule" not in data or not data["schedule"]:
                    print("No schedules found in the file.")
                    return

                # Display each schedule entry
                print("\nCurrent Schedule:")
                print("-" * 40)
                for i, entry in data["schedule"]:
                    print(f"{i} .Time: {entry['time']}\nMessage: {entry['message']}")
                    print("-" * 40)

            except FileNotFoundError:
                print("schedule.json file not found. Please create a schedule first.")
            except json.JSONDecodeError:
                print("Error decoding the JSON file. Please check the file format.")
            except Exception as e:
                print(f"An unexpected error occurred: {e}")

    request :: 
        make a edit schedule method and then ask for index to edit the schedule entries,
        ask for what you want to edit : time/msg/both?
        then make changes accordingly in the json

---------------------------------------------------------------------------
    existing setTimer::
    def setTimer(self, query):
        """
        Set a timer based on the input query string and save it to timer.json.
        """
        # Extract hours, minutes, and seconds
        hours, minutes, seconds = self._extract_time_timer(query)
        if hours == 0 and minutes == 0 and seconds == 0:
            print("No valid time duration found in the query.")
            return

        # Get the current time and calculate the ring time
        current_time = datetime.now()
        ring_time = current_time + timedelta(
            hours=hours, minutes=minutes, seconds=seconds
        )

        # Prepare the timer details
        timer_id = (
            f"t{int(datetime.timestamp(current_time))}_{random.randint(1000, 9999)}"
        )
        set_time = (current_time.hour, current_time.minute, current_time.second)
        ring_time_tuple = (ring_time.hour, ring_time.minute, ring_time.second)

        timer_details = {
            "id": timer_id,
            "setTime": set_time,
            "ringTime": ring_time_tuple,
            "ringed": False,
        } 

        # Save to timer.json
        with open(self.timer_file, "r+") as f:
            data = json.load(f)
            data["timers"].append(timer_details)
            f.seek(0)
            json.dump(data, f, indent=4)

        print(f"Timer set successfully! Timer-ID:{timer_id}.")
    
    in json file store the current date too:
            "id": timer_id,
            "setTime": set_time,
            "ringTime": ring_time_tuple,
            "createDate": today's date, #format "DD-MM-YY"
            "ringed": False,

---------------------------------------------------------------------------
    this is remove_timer::
        def remove_timer(self):
        """
        Remove timers from timer.json where ringed=true.
        """
        with open(self.timer_file, "r+") as f:
            data = json.load(f)

            # Filter out timers with ringed=true
            timers_before = len(data["timers"])
            data["timers"] = [
                timer for timer in data["timers"] if not timer.get("ringed", False)
            ]

            timers_after = len(data["timers"])
            removed_timers = timers_before - timers_after

            # Overwrite the JSON file with updated data
            f.seek(0)
            f.truncate()
            json.dump(data, f, indent=4)

        print(f"Removed {removed_timers} timers where ringed=true.")

    add functionality::
        add one more thing:
            compare current time with the createDate in json if it is less than today's date then remove that too.
            json file:
            "
            {
            "timers": [
                {
                "id": "t1736703795_3434",
                "setTime": [23, 13, 15],
                "ringTime": [23, 13, 25],
                "createDate": "3-01-25",
                "ringed": true
                },
                {
                "id": "t1736703795_7510",
                "setTime": [23, 13, 15],
                "ringTime": [23, 14, 30],
                "createDate": "12-01-25",
                "ringed": true
                },
                {
                "id": "t1736852104_8395",
                "setTime": [16, 25, 4],
                "ringTime": [16, 25, 14],
                "createDate": "14-01-25",
                "ringed": false
                },
                {
                "id": "t1736852574_9301",
                "setTime": [16, 32, 54],
                "ringTime": [16, 33, 4],
                "createDate": "14-01-25",
                "ringed": false
                }
            ]
            }

            "
---------------------------------------
    Make function::
        def compareSent(main_qury,[]):

    logic::
        compareSent have two arguments. 1. main string 2. list of strings
        compare the main string with the list of strings and return true if every character of a mainstring matches with every character of list of strings.
        make a probability of it. if probability is greater than 90% then return true. that the mainstring matches with the list of strings.
        ex: mainquery= "helo there", list to compare=["hello there","hello"] then returns true: this is a row example i told you so that u can understand
        you can enhance the logic of this method and make it fully working comparison strings function using probability.

        edit the logic for this example:
            when the main_query="are you there moin",
            and list of strings=["yo there","are you there","you there"]

            then the program should check if one/more strings of the list of strings is in the main_query with probability and return true if it is greater then 90%
            so here in this example it will return 100% true because "you there" from the list of strings is in the main_query,
            so i want this program to work like that


            
    compareSent("are you there moin", ["yo there", "are you there", "yuo there"])
    take this as example:: 
        in the program first check: every character of "yo there" is in main query: returns 100% probability for this one
        in the program first check: every character of "are you there" is in main query: returns 100% probability for this one
        in the program first check: every character of "yuo there" is in main query: returns 100% probability for this one as "you" and "yuo" has same characters

-----------------------------------------------------------------------------------------

    make a 

    self.tag_to_patterns={'greetask': ['how are you', 'how you', 'how r u', 'hau r u'], 'greetell': ['i am fine', 'i m fine', 'i am great', 'i m great', 'i am doing well', 'i m doing well']}